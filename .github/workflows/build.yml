name: Build

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag name for release (e.g., v0.1a). Leave empty to build artifacts only.'
        required: false
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          libgtk-3-dev \
          libayatana-appindicator3-dev \
          pkg-config \
          libgirepository1.0-dev \
          gobject-introspection \
          libgraphene-1.0-dev \
          wget

    - name: Install Task
      uses: go-task/setup-task@v1

    - name: Setup pkg-config symlinks
      run: |
        mkdir -p build/.pkgconfig build/include/libappindicator
        ln -sf /usr/lib/x86_64-linux-gnu/pkgconfig/ayatana-appindicator3-0.1.pc build/.pkgconfig/appindicator3-0.1.pc
        ln -sf /usr/include/libayatana-appindicator3-0.1/libayatana-appindicator/app-indicator.h build/include/libappindicator/app-indicator.h

    - name: Download Go dependencies
      run: go mod download

    - name: Build binary
      env:
        PKG_CONFIG_PATH: ${{ github.workspace }}/build/.pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig
        CGO_CFLAGS: -I${{ github.workspace }}/build/include
        CGO_ENABLED: "1"
      run: |
        mkdir -p bin
        go build -ldflags '-s -w' -o bin/postnote .
        chmod +x bin/postnote

    - name: Build AppImage
      env:
        PKG_CONFIG_PATH: ${{ github.workspace }}/build/.pkgconfig:/usr/lib/x86_64-linux-gnu/pkgconfig
        CGO_CFLAGS: -I${{ github.workspace }}/build/include
        CGO_ENABLED: "1"
      run: |
        chmod +x scripts/build-appimage.sh
        ./scripts/build-appimage.sh

    - name: Package binary
      run: |
        cd bin
        # Create zip with executable permissions preserved
        zip postnote-linux-x86_64.zip postnote
        cd ..

    - name: Upload binary artifact
      uses: actions/upload-artifact@v4
      with:
        name: postnote-binary
        path: |
          bin/postnote
          bin/postnote-linux-x86_64.zip
        retention-days: 30

    - name: Upload AppImage artifact
      uses: actions/upload-artifact@v4
      with:
        name: postnote-appimage
        path: dist/postnote-*.AppImage
        retention-days: 30

    - name: Determine release tag
      id: release_tag
      run: |
        echo "Event name: ${{ github.event_name }}"
        echo "Ref: ${{ github.ref }}"
        if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.tag }}" ]; then
          echo "Using workflow_dispatch tag: ${{ github.event.inputs.tag }}"
          echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          echo "Using tag from ref: $TAG_NAME"
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
        else
          echo "No release tag will be created (not a tag push or workflow_dispatch with tag)"
        fi
        echo "Release tag output: ${{ steps.release_tag.outputs.tag }}"

    - name: Find AppImage file
      id: appimage
      if: steps.release_tag.outputs.tag != ''
      run: |
        echo "Looking for AppImage files in dist/..."
        ls -la dist/ || echo "Warning: dist/ directory does not exist"
        APPIMAGE_FILE=$(ls dist/postnote-*.AppImage 2>/dev/null | head -n 1)
        if [ -z "$APPIMAGE_FILE" ]; then
          echo "Error: AppImage file not found in dist/"
          echo "Contents of dist/ directory:"
          ls -la dist/ 2>&1 || echo "dist/ directory does not exist"
          exit 1
        fi
        echo "file=$APPIMAGE_FILE" >> $GITHUB_OUTPUT
        echo "Found AppImage: $APPIMAGE_FILE"

    - name: Package AppImage
      if: steps.release_tag.outputs.tag != ''
      run: |
        APPIMAGE_FILE="${{ steps.appimage.outputs.file }}"
        if [ -n "$APPIMAGE_FILE" ] && [ -f "$APPIMAGE_FILE" ]; then
          APPIMAGE_NAME=$(basename "$APPIMAGE_FILE" .AppImage)
          cd dist
          zip "${APPIMAGE_NAME}.zip" "$(basename "$APPIMAGE_FILE")"
          echo "appimage_zip=${APPIMAGE_NAME}.zip" >> $GITHUB_OUTPUT
          cd ..
        fi
      id: package_appimage

    - name: Verify release files exist
      if: steps.release_tag.outputs.tag != ''
      run: |
        if [ ! -f "bin/postnote" ]; then
          echo "Error: bin/postnote not found"
          exit 1
        fi
        if [ ! -f "bin/postnote-linux-x86_64.zip" ]; then
          echo "Error: bin/postnote-linux-x86_64.zip not found"
          exit 1
        fi
        APPIMAGE_ZIP="${{ steps.package_appimage.outputs.appimage_zip }}"
        if [ -z "$APPIMAGE_ZIP" ]; then
          echo "Error: AppImage zip file path is empty"
          ls -la dist/ || echo "dist/ directory does not exist"
          exit 1
        fi
        if [ ! -f "dist/$APPIMAGE_ZIP" ]; then
          echo "Error: AppImage zip file not found: dist/$APPIMAGE_ZIP"
          ls -la dist/ || echo "dist/ directory does not exist"
          exit 1
        fi
        echo "âœ… All release files verified:"
        ls -lh bin/postnote-linux-x86_64.zip
        ls -lh "dist/$APPIMAGE_ZIP"

    - name: Create GitHub Release
      if: steps.release_tag.outputs.tag != ''
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.release_tag.outputs.tag }}
        name: Release ${{ steps.release_tag.outputs.tag }}
        files: |
          bin/postnote-linux-x86_64.zip
          dist/${{ steps.package_appimage.outputs.appimage_zip }}
        generate_release_notes: true
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

